# -*- coding: utf-8 -*-
"""Pneumonia_Detection_from_Chest_X_Rays_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DZJHZpdufdpVrihnoai621VXrZDAlkq0
"""

from google.colab import drive
drive.mount('/content/drive')

from google.colab import files
uploaded = files.upload()  # Upload kaggle.json

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

!pip install kaggle
!kaggle datasets download -d paultimothymooney/chest-xray-pneumonia -p /content/drive/MyDrive/chest_xray_dataset

!pip install gradio tensorflow numpy matplotlib opencv-python-headless

import gradio as gr
import tensorflow as tf
import numpy as np
import cv2
import matplotlib.pyplot as plt
from tensorflow.keras.applications import VGG16
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D
from tensorflow.keras.models import Model
import os
from sklearn.metrics import classification_report, confusion_matrix

# Define the model using VGG16 with fine-tuning
def build_model():
    base_model = VGG16(weights='imagenet', include_top=False, input_shape=(224, 224, 3))
    x = base_model.output
    x = GlobalAveragePooling2D()(x)
    x = Dense(128, activation='relu')(x)
    predictions = Dense(1, activation='sigmoid')(x)
    model = Model(inputs=base_model.input, outputs=predictions)

    # Unfreeze the last few layers for fine-tuning
    for layer in base_model.layers[:-4]:  # Freeze all layers except the last 4
        layer.trainable = False
    for layer in base_model.layers[-4:]:
        layer.trainable = True

    model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=1e-5),  # Lower learning rate for fine-tuning
                  loss='binary_crossentropy', metrics=['accuracy'])
    return model

# Function to load and preprocess the dataset with data augmentation
def load_data():
    train_dir = '/content/drive/MyDrive/chest_xray_dataset/chest_xray/train'
    test_dir = '/content/drive/MyDrive/chest_xray_dataset/chest_xray/test'

    # Data augmentation for the minority class (Normal)
    train_datagen = tf.keras.preprocessing.image.ImageDataGenerator(
        rescale=1./255,
        rotation_range=20,
        width_shift_range=0.2,
        height_shift_range=0.2,
        shear_range=0.2,
        zoom_range=0.2,
        horizontal_flip=True,
        fill_mode='nearest',
        validation_split=0.2
    )
    test_datagen = tf.keras.preprocessing.image.ImageDataGenerator(rescale=1./255)

    train_generator = train_datagen.flow_from_directory(
        train_dir,
        target_size=(224, 224),
        color_mode='rgb',
        batch_size=32,
        class_mode='binary',
        subset='training'
    )

    val_generator = train_datagen.flow_from_directory(
        train_dir,
        target_size=(224, 224),
        color_mode='rgb',
        batch_size=32,
        class_mode='binary',
        subset='validation'
    )

    test_generator = test_datagen.flow_from_directory(
        test_dir,
        target_size=(224, 224),
        color_mode='rgb',
        batch_size=32,
        class_mode='binary',
        shuffle=False
    )

    return train_generator, val_generator, test_generator

# Function to compute class weights to handle imbalance
def compute_class_weights(train_generator):
    # Count the number of samples in each class
    num_normal = len(os.listdir('/content/drive/MyDrive/chest_xray_dataset/chest_xray/train/NORMAL'))
    num_pneumonia = len(os.listdir('/content/drive/MyDrive/chest_xray_dataset/chest_xray/train/PNEUMONIA'))
    total = num_normal + num_pneumonia

    # Compute class weights
    weight_for_normal = (1 / num_normal) * (total / 2.0)
    weight_for_pneumonia = (1 / num_pneumonia) * (total / 2.0)
    class_weights = {0: weight_for_normal, 1: weight_for_pneumonia}

    return class_weights

# Function to train the model
def train_model():
    model = build_model()
    train_generator, val_generator, test_generator = load_data()
    class_weights = compute_class_weights(train_generator)

    # Train the model with class weights
    model.fit(
        train_generator,
        epochs=10,  # Increase epochs for better training
        validation_data=val_generator,
        class_weight=class_weights
    )

    # Evaluate on test set
    test_loss, test_accuracy = model.evaluate(test_generator)
    print(f"Test Accuracy: {test_accuracy * 100:.2f}%")

    # Generate classification report and confusion matrix
    y_pred = (model.predict(test_generator) > 0.5).astype(int)
    y_true = test_generator.classes
    print("Classification Report:")
    print(classification_report(y_true, y_pred, target_names=['Normal', 'Pneumonia']))
    print("Confusion Matrix:")
    print(confusion_matrix(y_true, y_pred))

    # Save the model to Google Drive
    model.save('/content/drive/MyDrive/pneumonia_vgg16_finetuned_model.h5')
    return model

# Function to preprocess the input image
def preprocess_image(image):
    img = cv2.resize(image, (224, 224))
    if len(img.shape) == 2:
        img = cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)
    img = img / 255.0
    img = np.expand_dims(img, axis=0)
    return img

# Function to generate Grad-CAM heatmap
def generate_gradcam_heatmap(model, img_array):
    grad_model = tf.keras.models.Model(
        [model.inputs], [model.get_layer('block5_conv3').output, model.output]
    )
    with tf.GradientTape() as tape:
        conv_outputs, predictions = grad_model(img_array)
        loss = predictions[:, 0]
    grads = tape.gradient(loss, conv_outputs)[0]
    pooled_grads = tf.reduce_mean(grads, axis=(0, 1, 2))
    conv_outputs = conv_outputs[0]
    heatmap = tf.reduce_mean(conv_outputs * pooled_grads, axis=-1)
    heatmap = np.maximum(heatmap, 0) / np.max(heatmap)
    return heatmap

# Function to overlay heatmap on the original image
def overlay_heatmap(heatmap, image):
    heatmap = cv2.resize(heatmap, (image.shape[1], image.shape[0]))
    heatmap = np.uint8(255 * heatmap)
    heatmap = cv2.applyColorMap(heatmap, cv2.COLORMAP_JET)
    superimposed_img = heatmap * 0.4 + image
    superimposed_img = np.clip(superimposed_img, 0, 255).astype(np.uint8)
    return superimposed_img

# Function to classify the image and generate results
def classify_pneumonia(image):
    img_array = preprocess_image(image)

    # Load or train the model
    if os.path.exists('/content/drive/MyDrive/pneumonia_vgg16_finetuned_model.h5'):
        model = tf.keras.models.load_model('/content/drive/MyDrive/pneumonia_vgg16_finetuned_model.h5')
    else:
        model = train_model()

    # Predict
    prediction = model.predict(img_array)[0][0]
    confidence = prediction * 100 if prediction > 0.5 else (1 - prediction) * 100
    label = "Pneumonia" if prediction > 0.5 else "Normal"

    # Generate Grad-CAM heatmap
    heatmap = generate_gradcam_heatmap(model, img_array)
    if len(image.shape) == 2:
        image = cv2.cvtColor(image, cv2.COLOR_GRAY2RGB)
    superimposed_img = overlay_heatmap(heatmap, image)

    # Save the result image
    plt.figure(figsize=(6, 6))
    plt.imshow(superimposed_img)
    plt.title(f"Predicted: {label} ({confidence:.2f}%)")
    plt.axis('off')
    plt.savefig("result.png")
    plt.close()

    return f"Predicted: {label}\nConfidence: {confidence:.2f}%", "result.png"

# Function to reset the interface
def reset():
    return "", None

# Create the Gradio interface
with gr.Blocks(css="""
    .gradio-container {background-color: #e6f4ea; font-family: 'Helvetica', sans-serif;}
    h1 {color: #2e7d32; text-align: left; font-size: 24px; margin-bottom: 10px;}
    .gr-markdown {color: #333; font-size: 14px; margin-bottom: 20px;}
    .gr-button {background-color: #d3d3d3; color: #333; border: none; border-radius: 5px; padding: 10px 20px; font-size: 14px; margin: 5px;}
    .gr-button:hover {background-color: #b0b0b0;}
    .gr-textbox {border: 1px solid #ccc; border-radius: 5px; padding: 10px; background-color: white;}
    .gr-image {border: 1px solid #ccc; border-radius: 5px; padding: 5px; background-color: white;}
""") as interface:
    gr.Markdown("# Pneumonia Detection from Chest X-Rays")
    gr.Markdown("Upload a chest X-ray image to detect pneumonia. The system will classify the image as Normal or Pneumonia and highlight areas of interest.")

    with gr.Row():
        with gr.Column(scale=1):
            image_input = gr.Image(type="numpy", label="Upload Chest X-Ray")
            with gr.Row():
                classify_btn = gr.Button("Classify")
                reset_btn = gr.Button("Reset")

        with gr.Column(scale=1):
            result_text = gr.Textbox(label="Classification Result")

        with gr.Column(scale=1):
            result_image = gr.Image(label="Result with Heatmap")

    classify_btn.click(fn=classify_pneumonia, inputs=image_input, outputs=[result_text, result_image])
    reset_btn.click(fn=reset, inputs=None, outputs=[result_text, result_image])

# Launch the interface
interface.launch()

# Install Kaggle library
!pip install kaggle

# Upload kaggle.json
from google.colab import files
uploaded = files.upload()  # Upload your kaggle.json file

# Set up Kaggle API credentials
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

# Download the Chest X-Ray Images (Pneumonia) dataset
!kaggle datasets download -d paultimothymooney/chest-xray-pneumonia -p /content/drive/MyDrive/chest_xray_dataset

# Unzip the dataset
!unzip /content/drive/MyDrive/chest_xray_dataset/chest-xray-pneumonia.zip -d /content/drive/MyDrive/chest_xray_dataset

